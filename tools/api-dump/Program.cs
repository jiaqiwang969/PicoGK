using System.Reflection;
using System.Text;

// Dump PicoGK C# public API (reflection-based).
// Usage:
//   dotnet run --project tools/api-dump -c Release -- <output_path>
//
// The output is a stable-ish markdown list to help C# <-> Rust API completeness tracking.

string outputPath = args.Length > 0 ? args[0] : Path.Combine("picogk-rs", "CSHARP_PUBLIC_API.md");

Assembly asm = typeof(PicoGK.Library).Assembly;

var types = asm
    .GetExportedTypes()
    .Where(t => string.Equals(t.Namespace, "PicoGK", StringComparison.Ordinal))
    .OrderBy(t => t.FullName, StringComparer.Ordinal)
    .ToArray();

static string TypeName(Type t)
{
    if (t.IsGenericType)
    {
        string name = t.Name.Split('`')[0];
        string args = string.Join(", ", t.GetGenericArguments().Select(TypeName));
        return $"{name}<{args}>";
    }
    if (t.IsArray)
        return $"{TypeName(t.GetElementType()!)}[]";
    return t.Name;
}

static string MethodSig(MethodBase m)
{
    var ps = m.GetParameters();
    string parms = string.Join(", ", ps.Select(p => $"{TypeName(p.ParameterType)} {p.Name}"));
    return $"{m.Name}({parms})";
}

var sb = new StringBuilder();
sb.AppendLine("# PicoGK C# Public API (reflection dump)");
sb.AppendLine();
sb.AppendLine("Generated by `tools/api-dump`.");
sb.AppendLine();
sb.AppendLine($"- Assembly: `{asm.GetName().Name}`");
sb.AppendLine($"- Version: `{asm.GetName().Version}`");
sb.AppendLine($"- GeneratedAtUtc: `{DateTime.UtcNow:O}`");
sb.AppendLine();

foreach (var t in types)
{
    sb.AppendLine($"## {t.FullName}");
    sb.AppendLine();

    // Constructors
    var ctors = t.GetConstructors(BindingFlags.Public | BindingFlags.Instance)
        .OrderBy(c => MethodSig(c), StringComparer.Ordinal)
        .ToArray();
    if (ctors.Length > 0)
    {
        sb.AppendLine("### Constructors");
        foreach (var c in ctors)
            sb.AppendLine($"- `{MethodSig(c)}`");
        sb.AppendLine();
    }

    // Properties
    var props = t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static)
        .OrderBy(p => p.Name, StringComparer.Ordinal)
        .ToArray();
    if (props.Length > 0)
    {
        sb.AppendLine("### Properties");
        foreach (var p in props)
            sb.AppendLine($"- `{TypeName(p.PropertyType)} {p.Name}`");
        sb.AppendLine();
    }

    // Methods (exclude property/event special names)
    var methods = t.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static)
        .Where(m => !m.IsSpecialName)
        .OrderBy(m => MethodSig(m), StringComparer.Ordinal)
        .ToArray();
    if (methods.Length > 0)
    {
        sb.AppendLine("### Methods");
        foreach (var m in methods)
        {
            string ret = m is MethodInfo mi ? TypeName(mi.ReturnType) : "void";
            sb.AppendLine($"- `{ret} {MethodSig(m)}`");
        }
        sb.AppendLine();
    }

    // Fields
    var fields = t.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static)
        .OrderBy(f => f.Name, StringComparer.Ordinal)
        .ToArray();
    if (fields.Length > 0)
    {
        sb.AppendLine("### Fields");
        foreach (var f in fields)
            sb.AppendLine($"- `{TypeName(f.FieldType)} {f.Name}`");
        sb.AppendLine();
    }
}

Directory.CreateDirectory(Path.GetDirectoryName(outputPath) ?? ".");
File.WriteAllText(outputPath, sb.ToString(), new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
Console.WriteLine($"Wrote: {outputPath}");

